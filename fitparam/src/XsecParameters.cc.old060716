#include <fstream>
#include <sstream>
#include <iomanip>
#include <assert.h>

#include "XsecParameters.hh"

using namespace std;

//ctor
XsecParameters::XsecParameters(const char *name)
{
    m_name = name;
    Npar=0;
    //Now we want to define the xsec parameters in the fit. This needs to be in the same order as the response functions (splines)
    //are fed into the fitter. This is a bad fit od hard coding and should be improved at some point.
}

//dtor
XsecParameters::~XsecParameters()
{;}

// So much upsetting hard coding here, sorry!
// So below I've hacked in a fix to avoid the FSI params looking at cut branch (sample) 0 or 4
// (since these have no protons)
// and reaction 6 has been made to be reaaction 7 (since reaction 6 is not defined in mectopology HL2 cat)

// The dummy response function thing is also a bit of a hack. This allows the occasional job to fail when making
// resp functions and the fitter still runs but this is not good and should be delt with


// store response functions in vector of Xsec "bins" (Ereco, Etrue, reac, topo)
void XsecParameters::StoreResponseFunctions(vector<TFile*> respfuncs, std::vector<std::pair <double,double> > v_D1edges, std::vector<std::pair <double,double> > v_D2edges)
{
    double dummyx[7]={-1,-0.66,-0.33,0,0.33,0.66,1};
    double dummyy[7]={1,1,1,1,1,1,1};
    int    dummyn=7;
    
    //Now in the response production we want to set some definitions for the
    //target too. now we should be consistant with our implementation of both
    //the target and reaction. Should check that the reactions that splines a
    //are produced for are in here.
    
    int targ_list[2] = {1, 999};
    int reac_list[7] = {11, 13, 21, 26, 41, 46, 99};
    
    cout << "Inputing Response Functions..." << endl;
    
    //In each bin: We want to we want to get the splines assocaited to that reaction and topology
    
    for(int sam_cnt = 0; sam_cnt < 1; sam_cnt++){
        SampleTypes sampletype = static_cast <SampleTypes> (sam_cnt);
        
        int n_bins = (int)v_D1edges.size();
        
        for(int tr_b = 0; tr_b < n_bins; tr_b++){
            for(int re_b = 0; re_b < n_bins; re_b++){
                
                if( !(fabs(re_b-tr_b)<21) ) continue;//Save memory when bins are too far away.
                
                XsecBin bin;
                bin.topology = sampletype;
                bin.recoD1low = v_D1edges[re_b].first;
                bin.recoD1high = v_D1edges[re_b].second;
                bin.trueD1low = v_D1edges[tr_b].first; //same binning for reco and true
                bin.trueD1high = v_D1edges[tr_b].second;
                
                bin.recoD2low = v_D2edges[re_b].first;
                bin.recoD2high = v_D2edges[re_b].second;
                bin.trueD2low = v_D2edges[tr_b].first; //same binning for reco and true
                bin.trueD2high = v_D2edges[tr_b].second;
                
                //For each topology, target and reaction the xsec binninh must be pushed back.
                //We want to store all the response functions associated to that bin and related to a specific target and reaction type.
                for(int tar_cnt = 0; tar_cnt < 2; tar_cnt++){
                    
                    TargetTypes targettype = static_cast<TargetTypes>(targ_list[tar_cnt]);
                    
                    for(int reac_cnt = 0; reac_cnt < 7; reac_cnt++){
                        
                        ReactionTypes reactype = static_cast<ReactionTypes>(reac_list[reac_cnt]);
                        
                        bool good_reac = false;
                        
                        if(targ_list[tar_cnt] == 1){
                            switch (reac_list[reac_cnt]) {
                                case 11: good_reac = true; break;
                                case 21: good_reac = true; break;
                                case 26: good_reac = true; break;
                                case 99: good_reac = true; break;
                                default: good_reac = false; break;
                            }
                        }
                        else if(targ_list[tar_cnt] == 999){
                            switch (reac_list[reac_cnt]) {
                                case 11: good_reac = true; break;
                                case 13: good_reac = true; break;
                                case 21: good_reac = true; break;
                                case 26: good_reac = true; break;
                                case 41: good_reac = true; break;
                                case 99: good_reac = true; break;
                                default: good_reac = false; break;
                            }
                        }
                        
                        cout << "RecBin" << re_b << " TruBin" << tr_b << " Target " << targ_list[tar_cnt] << " Reac " << reac_list[reac_cnt] << " GOOD? ";
                        
                        if(good_reac){
                            cout << "YES " << endl;
                        
                            bin.reaction.push_back(reactype);
                            bin.target.push_back(targettype);
                            
                            char name[300];
                            sprintf(name,"topology_%d/RecBin%d_TrueBin%d_top%d_reac%d_tar%d",sam_cnt, re_b, tr_b, sam_cnt, reac_list[reac_cnt], targ_list[tar_cnt]);
                            
                            if(reac_list[reac_cnt] != 99){
                                cout << "Reac w/ spline " << endl;
                                for(int func_cnt = 0; func_cnt < Npar; func_cnt++){
                                    
                                    TString rfilename(respfuncs[func_cnt]->GetName());
                                    
                                    if(rfilename.Contains(Form("reac%d",reac_list[reac_cnt]),TString::kIgnoreCase) && rfilename.Contains(Form("tar%d.",targ_list[tar_cnt]), TString::kIgnoreCase)){
                                        
                                        TGraph* g=(TGraph*)respfuncs[func_cnt]->Get(name);
                                        
                                        if(!g){
                                            //if(i!=8 && br!=8 && bt!=8){ // Ignore Eb issues for the moment
                                            //cout << "Warning, creating dummy respfunc, param: " << func_cnt << " " << name << endl;
                                            //cout << "getchar to cont" << endl;
                                            //getchar();
                                            //}
                                            g = new TGraph(dummyn, dummyx, dummyy);
                                        }
                                        
                                        g->SetName(name);
                                        if((g->GetY())[3]!=1.0){
                                            cout << "Warning: altering xsec nominal param: " << func_cnt << " " << name << endl;
                                        }
                                        bin.respfuncs.push_back(g);
                                        bin.resexists.push_back(true);
                                    }
                                }
                            }
                            else{
                                cout << "Reac w/o Spline " << reac_list[reac_cnt] << endl;
                                TGraph * g = new TGraph(dummyn, dummyx, dummyy);
                                g->SetName(name);
                                bin.respfuncs.push_back(g);
                            }
                        }
                        else{
                            cout << "NO " << endl;
                        }
                    }
                }
                m_bins.push_back(bin);
                //28:06:16 : Now have every bin with the same number of response functions Tot. = N + 2.
            }
        }
    }
}

void XsecParameters::AddResponse(TString filename, TString param_name, double cov_val){

    TFile * file = new TFile(filename);
    
    m_resfiles.push_back(file);
    pars_name.push_back(Form("%s%d_%s", m_name.c_str(), (int)Npar, param_name.Data()));
    //cout << "Par Name: " << pars_name[(int)Npar] << endl;
    pars_prior.push_back(1);
    pars_step.push_back(0.11);
    pars_limlow.push_back(0.5);
    pars_limhigh.push_back(2.5);
    
    m_cov_val.push_back(cov_val);
    Npar++;
}

void XsecParameters::SetUpParams(std::vector<std::pair <double,double> > v_D1edges, std::vector<std::pair <double,double> > v_D2edges){
    
    cout << "  No. Pars = " << Npar <<endl;
    cout << "No. Priors = " << pars_prior.size() << endl;
    
    TMatrixDSym cov_xsec((int)Npar);
    
    for(int i = 0; i < (int)Npar; i++){
        for(int j = 0; j < (int)Npar; j++){
            
            if(i == j){
                cov_xsec(i,j) = m_cov_val[i];
            }
            else{
                cov_xsec(i,j) = 0.;
            }
        }
    }
    
    cov_xsec.Print();
    
    SetCovarianceMatrix(&cov_xsec);

    this->StoreResponseFunctions(m_resfiles, v_D1edges, v_D2edges);
}

// --
int XsecParameters::GetBinIndex(SampleTypes sampletype, int reac, int tar, double D1reco, double D1true, double D2reco, double D2true)
{
    //Cast the reaction type and target as ReactionTypes and TargetTypes:
    int tmp_reactype = 99;
    
    switch (reac) {
        case 11: tmp_reactype = 11; break;
        case 13: tmp_reactype = 13; break;
        case 21: tmp_reactype = 21; break;
        case 26: tmp_reactype = 26; break;
        case 41: tmp_reactype = 41; break;
        case 46: tmp_reactype = 46; break;
        default: tmp_reactype = 99; break;
    }
    
    ReactionTypes reactype = static_cast<ReactionTypes>(tmp_reactype);
    
    int tmp_target = 999;
    switch (tar) {
        case 1 :  tmp_target = 1;   break;
        default: tmp_target = 999; break;
    }
    
    TargetTypes target = static_cast<TargetTypes>(tmp_target);
    
    int binn = BADBIN;
    for(size_t i=0;i<m_bins.size();i++){
        
        if(target == Hydrogen && reactype == ReRec11 && D1true < 1e-5) continue;
        
        for(int k=0; k < (int)m_bins[i].reaction.size(); k++){
            for(int l=0; l < (int)m_bins[i].target.size(); l++){
                
                if(m_bins[i].topology == sampletype && m_bins[i].reaction[k] == reactype && m_bins[i].target[l] == target &&
                   (D1reco > m_bins[i].recoD1low) && (D1reco  < m_bins[i].recoD1high)  &&
                   (D2reco  > m_bins[i].recoD2low) && (D2reco  < m_bins[i].recoD2high) &&
                   (D1true > m_bins[i].trueD1low) && (D1true  < m_bins[i].trueD1high)  &&
                   (D2true  > m_bins[i].trueD2low) && (D2true  < m_bins[i].trueD2high)){
                    binn = (int)i;
                    break;
                }
            }
        }
    }
    
    cout<<"topology "<<sampletype<<" : reaction "<<reactype << " : target "<< target <<endl;
    cout<<"recoP "<<D1reco<<"  trueP "<<D1true<<"    recoD2 "<<D2reco<<"  trueD2 "<<D2true<<endl;
    cout<<"BIN "<<binn<<endl<<endl;
    
    return binn;
}

// initEventMap
void XsecParameters::InitEventMap(std::vector<AnaSample*> &sample)
{
    if(m_bins.empty())
    {
        cout<<"Need to build map of response functions for "<<m_name<<" ... exiting ..."<<endl;
        exit(-1);
    }
    m_evmap.clear();
    
    int counter = 0;
    //loop over events to build index map
    for(size_t s=0;s<sample.size();s++)
    {
        vector<int> row;
        for(int i=0;i<sample[s]->GetN();i++)
        {
            AnaEvent *ev = sample[s]->GetEvent(i);
            //skip reactions not prepared in response function
            /*int code = PASSEVENT;
             if(ev->GetReaction() == AntiNu ||
             ev->GetReaction() == OutFGD)
             {
             row.push_back(code);
             continue;
             }*/
            //get event info
            int binn = GetBinIndex(static_cast<SampleTypes>(ev->GetSampleType()), ev->GetNuReaction(), ev->GetTarget(), ev->GetRecD1trk(),ev->GetTrueD1trk(),ev->GetRecD2trk(),ev->GetTrueD2trk());
            /*if(binn == BADBIN)
            {
                cout<<"WARNING: "<<m_name<<" event "
                <<" fall outside bin ranges"<<endl;
                cout<<" This event will be ignored in analysis."
                <<endl;
                ev->Print();
                counter++;
            }*/
            
            row.push_back(binn);
        }//event loop
        m_evmap.push_back(row);
    }//sample loop
    
    //cout << "Number of bad events " << counter << endl;
}


// EventWeghts
void XsecParameters::EventWeights(std::vector<AnaSample*> &sample, std::vector<double> &params)
{
    for(size_t s=0;s<sample.size();s++)
    {
        for(int i=0;i<sample[s]->GetN();i++)
        {
            AnaEvent *ev = sample[s]->GetEvent(i);
            ReWeight(ev, s, i, params);
        }
    }
}

// ReWeight
void XsecParameters::ReWeight(AnaEvent *event, int nsample, int nevent, std::vector<double> &params)
{
    if(m_evmap.empty()) //need to build an event map first
    {
        cout<<"Need to build event map index for "<<m_name<<endl;
        return;
    }
    
    int binn = m_evmap[nsample][nevent];
    
    if(binn == PASSEVENT) return;
    if(binn == BADBIN)
        event->AddEvWght(0.0); //skip!!!!
    else
    {
        vector <TGraph*> respfuncs = m_bins[binn].respfuncs;
        double weight=1;
        if(respfuncs.size()>0){ //needed because there are missing reponse functions when reco very different from true (to save memory)
            for(uint i=0; i<Npar; i++){
                //This assumes that the response functions are always the same as the response functions.
                weight = weight*(respfuncs[i]->Eval(params[i]));
                //if(weight!=1)
                cout<<"reweighting using weight "<<weight<<"  from bin "<<binn<<endl;
            }
        }
        
        double prevWght = event->GetEvWght();
        event->AddEvWght(weight);
        double newWght = event->GetEvWght();
        
        //For debugging reweighting:
        // if(prevWght!=newWght){
        //   cout << "Reweighted! From " << prevWght << " to " << newWght << endl;
        //   getchar();
        // }
    }
}